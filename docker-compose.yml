# Docker Compose file for SFPLiberate
# Compose Spec (no version field needed for v2.40+)
# https://docs.docker.com/compose/compose-file/

name: sfpliberate

services:
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile.new
      args:
        - PYTHON_VERSION=${PYTHON_VERSION:-3.11}
        - POETRY_VERSION=${POETRY_VERSION:-1.8.5}
        - BUILD_DATE=${BUILD_DATE}
        - VCS_REF=${VCS_REF}
        - VERSION=${VERSION:-dev}
      # Enable BuildKit for better caching and performance
      cache_from:
        - type=registry,ref=ghcr.io/josiah-nelson/sfpliberate-backend:cache
      cache_to:
        - type=inline
    image: sfpliberate-backend:${VERSION:-latest}
    container_name: sfpliberate-backend

    # Restart policy
    restart: unless-stopped

    # Environment variables
    environment:
      # Deployment Mode (standalone=SQLite only for Docker deployments)
      # Note: Appwrite cloud deployment uses backend Functions, not Docker
      - DEPLOYMENT_MODE=standalone
      # SQLite configuration
      - DATABASE_FILE=/app/data/sfp_library.db
      - SUBMISSIONS_DIR=/app/data/submissions
      # Application settings
      - LOG_LEVEL=${LOG_LEVEL:-info}
      - PYTHONUNBUFFERED=1
      - ENVIRONMENT=${ENVIRONMENT:-production}
      # ESPHome Proxy (optional)
      - ESPHOME_PROXY_MODE=${ESPHOME_PROXY_MODE:-false}

    # Volumes
    volumes:
      - backend_data:/app/data:rw
      # Bind-mount .env to allow backend to persist profile UUIDs (self-hosted)
      - ./.env:/app/.env:rw

    # Network
    # Note: For ESPHome proxy to work, backend needs to reach LAN.
    # Comment out 'networks' and use 'network_mode: host' when using ESPHome
    # networks:
    #   - sfp-internal
    network_mode: host

    # Expose port internally (not to host) - not needed in host mode
    # expose:
    #   - "80"

    # Resource limits (adjust based on your needs)
    deploy:
      resources:
        limits:
          cpus: '1.0'
          memory: 512M
        reservations:
          cpus: '0.25'
          memory: 128M

    # Health check
    healthcheck:
      test: [ "CMD", "python", "-c", "import urllib.request; urllib.request.urlopen('http://localhost/api/modules').read()" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

    # Security options
    security_opt:
      - no-new-privileges:true
    read_only: true
    tmpfs:
      - /tmp
      - /app/.cache

    # Labels
    labels:
      - "com.sfpliberate.service=backend"
      - "com.sfpliberate.description=FastAPI backend for SFP module management"
      - "com.sfpliberate.version=${VERSION:-dev}"

  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
      args:
        - BUILD_DATE=${BUILD_DATE}
        - VCS_REF=${VCS_REF}
        - VERSION=${VERSION:-dev}
      cache_from:
        - type=registry,ref=ghcr.io/josiah-nelson/sfpliberate-frontend:cache
      cache_to:
        - type=inline
    image: sfpliberate-frontend:${VERSION:-latest}
    container_name: sfpliberate-frontend

    # Restart policy
    restart: unless-stopped

    # Depends on backend with health condition
    depends_on:
      backend:
        condition: service_healthy
        restart: true

    # Environment
    environment:
      - ENVIRONMENT=${ENVIRONMENT:-production}
      # Backend URL used for Next.js rewrites in standalone mode
      - BACKEND_URL=http://localhost
      # Note: Deployment mode is AUTO-DETECTED by frontend
      # Standalone mode when APPWRITE_SITE_* variables are absent (default here)
      - PORT=3000

    # Network - use host mode to reach backend on host network
    network_mode: host
    # In host mode, frontend binds directly to port 3000 on host
    # Access via reverse-proxy service on port 8080

    # networks:
    #   - sfp-internal

    # Resource limits
    deploy:
      resources:
        limits:
          cpus: '0.75'
          memory: 256M
        reservations:
          cpus: '0.1'
          memory: 64M

    # Health check
    healthcheck:
      test: [ "CMD", "node", "-e", "require('http').get('http://localhost:3000/', r => process.exit(r.statusCode < 500 ? 0 : 1))" ]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 10s

    # Security options
    security_opt:
      - no-new-privileges:true
    # Disabled read_only for Next.js 16 standalone mode compatibility
    # read_only: true
    tmpfs:
      - /tmp

    # Labels
    labels:
      - "com.sfpliberate.service=frontend"
      - "com.sfpliberate.description=Next.js frontend with API proxy"
      - "com.sfpliberate.version=${VERSION:-dev}"
      - "traefik.enable=true"
      - "traefik.http.routers.sfpliberate.rule=Host(`${DOMAIN:-localhost}`)"
      - "traefik.http.routers.sfpliberate.entrypoints=websecure"
      - "traefik.http.routers.sfpliberate.tls.certresolver=letsencrypt"
      - "traefik.http.services.sfpliberate.loadbalancer.server.port=3000"

  reverse-proxy:
    image: nginx:alpine
    container_name: sfpliberate-reverse-proxy
    restart: unless-stopped

    depends_on:
      frontend:
        condition: service_healthy
        restart: true

    # Expose port 8080 to host
    ports:
      - "${HOST_PORT:-8080}:80"

    # Bridge network to connect to host services
    network_mode: bridge
    extra_hosts:
      - "host.docker.internal:host-gateway"

    # Simple nginx config to proxy to frontend on host
    volumes:
      - type: tmpfs
        target: /var/cache/nginx
      - type: tmpfs
        target: /var/run

    command: |
      sh -c 'echo "
      server {
        listen 80;
        server_name localhost;

        location / {
          proxy_pass http://host.docker.internal:3000;
          proxy_http_version 1.1;
          proxy_set_header Upgrade \$$http_upgrade;
          proxy_set_header Connection \"upgrade\";
          proxy_set_header Host \$$host;
          proxy_set_header X-Real-IP \$$remote_addr;
          proxy_set_header X-Forwarded-For \$$proxy_add_x_forwarded_for;
          proxy_set_header X-Forwarded-Proto \$$scheme;
        }
      }
      " > /etc/nginx/conf.d/default.conf && nginx -g "daemon off;"'

    healthcheck:
      test: ["CMD", "wget", "--quiet", "--tries=1", "--spider", "http://localhost/"]
      interval: 30s
      timeout: 5s
      retries: 3
      start_period: 5s

    labels:
      - "com.sfpliberate.service=reverse-proxy"
      - "com.sfpliberate.description=Nginx reverse proxy for port 8080 access"

networks:
  sfp-internal:
    driver: bridge
    ipam:
      config:
        - subnet: 172.25.0.0/24
    labels:
      - "com.sfpliberate.network=internal"

volumes:
  # Named volume for backend data persistence
  # Docker manages this volume automatically - no need to create directories manually
  backend_data:
    driver: local
    labels:
      - "com.sfpliberate.volume=backend-data"
      - "com.sfpliberate.backup=true"
    # Volume is stored in Docker's volume directory (e.g., /var/lib/docker/volumes/)
    # To backup: docker run --rm -v sfpliberate_backend_data:/data -v $(pwd):/backup alpine tar czf /backup/backup.tar.gz /data
    # To restore: docker run --rm -v sfpliberate_backend_data:/data -v $(pwd):/backup alpine tar xzf /backup/backup.tar.gz
